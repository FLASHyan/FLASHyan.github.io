<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法练-删除链表中重复元素</title>
      <link href="2021/05/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
      <url>2021/05/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>算法练中将包含相关算法和一些与考研题目结合的C语言的算法题进行延伸思考，在用Java简单实现的同时，对内容深化并尝试C语言的叙述来更加巩固当前知识点。</p><h1 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h1><p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。返回同样按升序排列的结果链表。</p><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/5.8-1.1oj7ystv4nq8.png" alt="示例图"></p><h1 id="方法：一次遍历"><a href="#方法：一次遍历" class="headerlink" title="方法：一次遍历"></a>方法：一次遍历</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题的思路比较简单，因为是按升序排列的，所以重复的元素基本都是相邻着的，因此只需要比较相邻两个节点的值，就能判断出是否是重复的。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除链表中的重复元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        Node node1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node node3 = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        Node node4 = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        Node node5 = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        head.setNext(node1);</span><br><span class="line">        node1.setNext(node2);</span><br><span class="line">        node2.setNext(node3);</span><br><span class="line">        node3.setNext(node4);</span><br><span class="line">        node4.setNext(node5);</span><br><span class="line"></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">while</span> (h != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(h.getData() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            h = h.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        head = deleteDuplicates(head);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n**********************&quot;</span>);</span><br><span class="line"><span class="comment">// 打印删除重复元素后的链表</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(head.getData() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            head = head.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//算法主体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">deleteDuplicates</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head ==<span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.getNext() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//比较相邻两节点的值，若相等，就让cur的next指向下下个节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur.getData() == cur.getNext().getData())&#123;   </span><br><span class="line">                cur.setNext(cur.getNext().getNext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.getNext();    <span class="comment">//若相邻不相等，就让cur往后移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> Data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">private</span> Node next;  <span class="comment">//指针域</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> Data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> Data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node next)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/5.8-4.5hz4w7y5zsw0.png" alt="结果"></p><h2 id="算法主体"><a href="#算法主体" class="headerlink" title="算法主体"></a>算法主体</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head ==<span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">            ListNode cur = head;</span><br><span class="line">            <span class="keyword">while</span>(cur.next !=<span class="keyword">null</span> )&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.val == cur.next.val )&#123;</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(N)，N是链表长度</p><p>空间复杂度：O(1)</p><h1 id="扩展延伸"><a href="#扩展延伸" class="headerlink" title="扩展延伸"></a>扩展延伸</h1><h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/5.8-2.24ao3hcb35kw.jpg" alt="题图"></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><blockquote><p>算法的基本设计思想</p></blockquote><ul><li><p>算法的核心思想是用空间来换时间。使用辅助数组来记录链表中已经出现的数值，这样只用对链表进行一次遍历</p></li><li><p>因为|data|&lt;=0，所以辅助数组q的大小为n+1，让各个元素的初始值置为0，如果在遍历链表过程中首次出现|data|，就令这个q[|data|]为1，这样后面如果出现了第二次|data|，就可以把它从链表中删除。</p><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/5.8-3.1pzwdsxsibsw.png" alt="思路图"></p></li></ul><blockquote><p>用C语言描述单链表节点的数据类型定义</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;NODE;</span><br><span class="line">Typedef NODE *PNODE;</span><br></pre></td></tr></table></figure><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span> <span class="params">(PNODE h, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PNODE p=h, r;</span><br><span class="line">  <span class="keyword">int</span> *q, m;</span><br><span class="line">  q= (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));   <span class="comment">//申请n+1个位置的辅助空间</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">    *(q+i) = <span class="number">0</span>;<span class="comment">//将数组元素的初始值置为0</span></span><br><span class="line">  <span class="keyword">while</span>(p-&gt;link != null)</span><br><span class="line">  &#123;</span><br><span class="line">    m=p-&gt;link-&gt;data&gt;<span class="number">0</span>? p-&gt;link-&gt;data : -p-&gt;link-&gt;data;  <span class="comment">//判断正负，将条件全部变成绝对值</span></span><br><span class="line">    <span class="keyword">if</span>(*(q+m) == <span class="number">0</span>)<span class="comment">//判断此时该结点data是否出现过</span></span><br><span class="line">    &#123;</span><br><span class="line">      *(q+m) = <span class="number">1</span>;   <span class="comment">//首次出现，赋值1进行标记</span></span><br><span class="line">      p= p-&gt;link;   <span class="comment">//保留</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>   <span class="comment">//重复出现</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//删除该结点</span></span><br><span class="line">      r= p-&gt;link;</span><br><span class="line">      p-&gt;link = r-&gt;link;</span><br><span class="line">      <span class="built_in">free</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(m)</p><p>空间复杂度：O(n)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java -算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法练-环形链表</title>
      <link href="2021/04/29/%E7%AE%97%E6%B3%95%E7%BB%83-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>2021/04/29/%E7%AE%97%E6%B3%95%E7%BB%83-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中存在环，就返回true。否则，返回false。</p><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/shili.png" alt="示例"></p><h1 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个方法就是遍历整个链表中的所有节点，每遍历一个节点就判断它此前是否被访问过</p><p>用哈希表来存储已经访问过的节点，之后每到达一个节点时，如果该节点已经在哈希表里，就说明这个链表中有环</p><p>否则就把这个节点存入进去，重复这么一个过程，直到整个链表被遍历完</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表判断链表中是否有环</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        test bean = <span class="keyword">new</span> test();</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        Node node1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        Node node3 = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        Node node4 = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        Node node5 = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        head.setNext(node1);</span><br><span class="line">        node1.setNext(node2);</span><br><span class="line">        node2.setNext(node3);</span><br><span class="line">        node3.setNext(node4);</span><br><span class="line">        node4.setNext(node3);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;&quot;</span> + bean.cycle(head));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表算法主体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">cycle</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Set&lt;Node&gt; seen = <span class="keyword">new</span> HashSet&lt;Node&gt;();   <span class="comment">//Hashset是基于Hashmap来实现的，是一个不允许有重复元素的集合</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!seen.add(head))&#123;    <span class="comment">//判断能否加入元素，若不能，说明存在环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> Data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">private</span> Node next;  <span class="comment">//指针域</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> Data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> Data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node next)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了HashSet，HashSet是基于Hashmap来实现的，是一个不允许有重复元素的集合</p><p>添加元素用add()方法</p><h2 id="算法主体"><a href="#算法主体" class="headerlink" title="算法主体"></a>算法主体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">cycle</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Set&lt;Node&gt; seen = <span class="keyword">new</span> HashSet&lt;Node&gt;();   <span class="comment">//Hashset是基于Hashmap来实现的，是一个不允许有重复元素的集合</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!seen.add(head))&#123;    <span class="comment">//判断能否加入元素，若不能，说明存在环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(N)，N是链表的节点数。最坏情况需要把链表中每一个节点遍历一次。</p><p>空间复杂度：O(N)，N是链表的节点数。主要是为哈希表的开销，最坏情况需要把每个节点插入到哈希表中一次。</p><p>思考：能不能用O(1)的空间复杂度来解决这个问题。</p><h1 id="方法二：快慢指针"><a href="#方法二：快慢指针" class="headerlink" title="方法二：快慢指针"></a>方法二：快慢指针</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这个方法称为Floyd判圈算法(又称为龟兔赛跑算法)</p><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88.38jri9mcjf40.png" alt="快慢指针思路图"></p><p>在开始的时候给定两个指针，一个快，一个慢</p><p>如果链表中存在环，那么快指针会在某一时刻追上慢指针，即二者相等，而快指针已经套了慢指针几圈了</p><p>如果链表不存在环，那么快指针就会先入空或指向空</p><p>这样循环条件都得到了</p><p>注意：因为判断是否追上的条件是<code>fast == slow</code>，所以<code>slow</code>一开始在head节点，那么<code>fast</code>就要在下一个节点，以防二者一开始就相等破坏循环条件。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快慢指针判断链表中是否有环</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        test bean = <span class="keyword">new</span> test();</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        Node node1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        Node node3 = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        Node node4 = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        Node node5 = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        head.setNext(node1);</span><br><span class="line">        node1.setNext(node2);</span><br><span class="line">        node2.setNext(node3);</span><br><span class="line">        node3.setNext(node4);</span><br><span class="line">        node4.setNext(node3);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;&quot;</span> + bean.cycle(head));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双指针算法主体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">cycle</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.getNext() == <span class="keyword">null</span>)&#123;     <span class="comment">//链表为空或者只有一个节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义两个快慢指针</span></span><br><span class="line">        Node slow = head;</span><br><span class="line">        Node fast = head.getNext();</span><br><span class="line">        <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.getNext() == <span class="keyword">null</span>)&#123;    <span class="comment">//无环条件，快的那个指针先入空或者指向空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.getNext();      <span class="comment">//慢的指针一次走一步</span></span><br><span class="line">            fast = fast.getNext().getNext();    <span class="comment">//快的指针一次走两步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> Data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">private</span> Node next;  <span class="comment">//指针域</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> Data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> Data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node next)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法主体-1"><a href="#算法主体-1" class="headerlink" title="算法主体"></a>算法主体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">cycle</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.getNext() == <span class="keyword">null</span>)&#123;     <span class="comment">//链表为空或者只有一个节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义两个快慢指针</span></span><br><span class="line">        Node slow = head;</span><br><span class="line">        Node fast = head.getNext();</span><br><span class="line">        <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.getNext() == <span class="keyword">null</span>)&#123;    <span class="comment">//无环条件，快的那个指针先入空或者指向空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.getNext();      <span class="comment">//慢的指针一次走一步</span></span><br><span class="line">            fast = fast.getNext().getNext();    <span class="comment">//快的指针一次走两步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(N)，其中 N 是链表中的节点数。</p><p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p><p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。</p><p>空间复杂度：O(1)。只使用了两个指针的额外空间。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java -算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法练-反转单链表</title>
      <link href="2021/04/28/%E7%AE%97%E6%B3%95%E7%BB%83-%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>2021/04/28/%E7%AE%97%E6%B3%95%E7%BB%83-%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给单链表的头节点 <code>head</code> ，请反转链表，并返回反转后的链表。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><h1 id="方法一：-双指针迭代"><a href="#方法一：-双指针迭代" class="headerlink" title="方法一： 双指针迭代"></a>方法一： 双指针迭代</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/fanzhuanlianbiao.5qh2agfbvps0.png" alt="迭代思路图"></p><p>&ensp;&ensp;&ensp;&ensp;首先要引入两个指针，分别是<code>prev</code>和<code>curr</code>,因为要把链表反转，那么就必须对next做文章，通过<code>curr</code>指针让当前节点的next指向上一个节点，而上一个节点由<code>prev</code>指针来表示。指向更改后两个指针往后移位。</p><p>&ensp;&ensp;&ensp;&ensp;但是在这里有一个问题，就是当<code>curr.next-&gt;prev</code>后，如图，节点1和节点2之间就断开了，那么<code>curr</code>指针就无法进行后移操作，所以我们还需要一个临时变量<code>next</code>，在将<code>curr.next-&gt;prev</code>前，先将<code>curr</code>的下一个节点暂时保存在这个临时变量<code>next</code>中，等第一个节点反转之后，<code>prev</code>后移，再将next里的值给到<code>curr</code>实现其后移。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代法实现反转链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        Node node1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        Node node3 = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        Node node4 = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        Node node5 = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        head.setNext(node1);</span><br><span class="line">        node1.setNext(node2);</span><br><span class="line">        node2.setNext(node3);</span><br><span class="line">        node3.setNext(node4);</span><br><span class="line">        node4.setNext(node5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印反转前的链表</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">while</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(h.getData() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            h = h.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用迭代的反转方法</span></span><br><span class="line">        head = reverse(head);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n**************************&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印反转后的结果</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != head) &#123;</span><br><span class="line">            System.out.print(head.getData() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            head = head.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代算法主体部分</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverse</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;         <span class="comment">//判断链表是否为空</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        Node prev = <span class="keyword">null</span>;</span><br><span class="line">        Node curr = head;</span><br><span class="line">        Node temp;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;          <span class="comment">//当curr为null，说明现在为尾结点</span></span><br><span class="line">            temp = curr.getNext();      <span class="comment">//临时变量，存放下一个节点</span></span><br><span class="line">            curr.setNext(prev);         <span class="comment">//更改next指向</span></span><br><span class="line">            <span class="comment">//两个指针后移</span></span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;    <span class="comment">//prev变为表头，返回prev</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> Data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">private</span> Node next;  <span class="comment">//指针域</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> Data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> Data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码给与实例结合迭代算法实现链表反转</p><h2 id="算法主体"><a href="#算法主体" class="headerlink" title="算法主体"></a>算法主体</h2><p>现将迭代算法主体部分列出，结合思路图达到更好的分析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverse</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;         <span class="comment">//判断链表是否为空</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        Node prev = <span class="keyword">null</span>;</span><br><span class="line">        Node curr = head;</span><br><span class="line">        Node temp;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;          <span class="comment">//当curr为null，说明现在为尾结点</span></span><br><span class="line">            temp = curr.next;      <span class="comment">//临时变量，存放下一个节点</span></span><br><span class="line">            curr.next = prev;         <span class="comment">//更改next指向</span></span><br><span class="line">            <span class="comment">//两个指针后移</span></span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;    <span class="comment">//prev变为表头，返回prev</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(N)，N是链表长度，因为需要遍历链表一次</p><p>空间复杂度：O(1)</p><h1 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/digui.77mpm5vqq300.png" alt="递归思路图"></p><p>通过不断调用函数递归，在归的过程中将节点指向反向，这里用<code>head.next.next = head;</code></p><p>往上的过程中，子节点已经反转好，让自己和子节点进行反转即可</p><p>递归结束的条件，当前链表为空或者链表里只有一个节点(因为此时不需要反转)</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归法实现反转链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        Node node1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        Node node3 = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        Node node4 = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        Node node5 = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        head.setNext(node1);</span><br><span class="line">        node1.setNext(node2);</span><br><span class="line">        node2.setNext(node3);</span><br><span class="line">        node3.setNext(node4);</span><br><span class="line">        node4.setNext(node5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印反转前的链表</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">while</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(h.getData() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            h = h.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用迭代的反转方法</span></span><br><span class="line">        head = reverse1(head);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n**************************&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印反转后的结果</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != head) &#123;</span><br><span class="line">            System.out.print(head.getData() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            head = head.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归算法主体部分</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverse1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归结束的条件，当前链表为空或者链表里只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.getNext() == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        Node newHead = reverse1(head.getNext());     <span class="comment">//递归调用</span></span><br><span class="line">        head.getNext().setNext(head);               <span class="comment">//节点反向</span></span><br><span class="line">        head.setNext(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> newHead;                <span class="comment">//这是反转后的表头，在函数出栈的过程中这个返回值一直没有变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> Data;   <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">private</span> Node next;  <span class="comment">//指针域</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> Data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> Data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法主体-1"><a href="#算法主体-1" class="headerlink" title="算法主体"></a>算法主体</h2><p>现将递归算法主体部分列出，结合思路图达到更好的分析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归算法主体部分</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverse1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归结束的条件，当前链表为空或者链表里只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        Node newHead = reverse1(head.next);     <span class="comment">//递归调用</span></span><br><span class="line">        head.next.next = head;<span class="comment">//节点反向</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;                <span class="comment">//这是反转后的表头，在函数出栈的过程中这个返回值一直没有变</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>递归算法不太好理解，可以认为是大问题一步步分解成小问题，再返回上一级问题执行同样的操作，一步步还回去。这类问题分清楚递和归的过程。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(N)，假设 N 是列表的长度，那么时间复杂度为 O(N)。<br>空间复杂度：O(N)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 N 层。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java -算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法练-两数之和</title>
      <link href="2021/04/27/%E7%AE%97%E6%B3%95%E7%BB%83-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>2021/04/27/%E7%AE%97%E6%B3%95%E7%BB%83-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><h1 id="方法一-暴力枚举"><a href="#方法一-暴力枚举" class="headerlink" title="方法一: 暴力枚举"></a>方法一: 暴力枚举</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通过枚举数组中的每一个数，组合来查找是否有适合<code>target</code>的两个整数</p><p>设两个数分别是x , y,他们的下标是i , j</p><p>两个循环，第一个找一个x，x前面的数都和x匹配过了，所以只需要去找x后面的数，即从j=i+1开始找y</p><p>找到了x和y就可以将两个下标输出</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力枚举找出两数之和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nums[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">17</span> ;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> Solution().twoSum(nums, target);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : result) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = nums.length;                     <span class="comment">//获取数组长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;        <span class="comment">//x只要找到倒数第二个，后面的会和x匹配</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;    <span class="comment">//i的前面不用去考虑，考虑i后面的</span></span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];  </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(N^2^)，最坏情况下数组中任意两个数都要进行匹配</p><p>空间复杂度：O(1)</p><p>对于这种情况，一般用空间去换时间，所以要进行一下优化</p><h1 id="方法二-哈希表"><a href="#方法二-哈希表" class="headerlink" title="方法二: 哈希表"></a>方法二: 哈希表</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>创建一个哈希表，先将数组第一个数存进去，并从第二个元素开始查找，让<code>target - nums[i]</code>与存放在哈希表中的<code>key</code>匹配，没有匹配的就存进哈希表中，如果匹配成功就输出这两个元素及下标 </p><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/hashmap.50pj6du1kxo0.png" alt="哈希表思路"></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nums[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">18</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> Solution().twoSum(nums, target);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : result) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//初始化哈希表，指定哈希表的容量以防止哈希表扩容带来性能的消耗</span></span><br><span class="line">          <span class="comment">//这里指定哈希表的容量为len-1，是因为最后一个元素全部比较过了</span></span><br><span class="line">            Map&lt;Integer, Integer&gt; hashtable = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;(len -<span class="number">1</span> );</span><br><span class="line">            hashtable.put(nums[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;  <span class="comment">//从第二个开始比较</span></span><br><span class="line">                <span class="keyword">int</span> another = target -nums[i];</span><br><span class="line">                <span class="keyword">if</span> (hashtable.containsKey(another)) &#123;<span class="comment">//寻找有没有key与another对应</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;hashtable.get(another), i&#125;;<span class="comment">//找到，返回值和下标</span></span><br><span class="line">                &#125;</span><br><span class="line">                hashtable.put(nums[i], i);<span class="comment">//没有匹配，存入哈希表中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。</p><p>空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java -算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的创建和遍历的实现(Java)</title>
      <link href="2021/04/25/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0(Java)/"/>
      <url>2021/04/25/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86%E7%9A%84%E5%AE%9E%E7%8E%B0(Java)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前站点上的文章，搬过来一下</p><p>（一点学习记录和问题思考）</p><p>创建单链表并实现数据的增删改查…</p><h2 id="案例内容"><a href="#案例内容" class="headerlink" title="案例内容"></a>案例内容</h2><p>将水浒英雄作为元素加进去，并且对他们进行排序输出，使用带head节点的单链表，实现一个水浒英雄排行榜管理，有两种方法:</p><ol><li>添加英雄时，直接添加到链表尾部</li><li>根据排名将英雄插入到指定位置（如果有这个排名，则添加失败，给出提示）</li></ol><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>思路：</p><ol><li>要先创造一个头节点，作为链表的头(力扣里把他叫做哨兵节点)，因为需要判断链表是否为空</li><li>之后每添加一个节点，就把他放在链表的尾部</li><li>关键是遍历，因为有了一个头节点，且这个头节点是不能移动的(注释有讲)，所以需要一个<strong>辅助变量</strong>来遍历整个链表</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroNode hero1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>,<span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode hero2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>,<span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode hero3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>,<span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode hero4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;公孙胜&quot;</span>,<span class="string">&quot;入云龙&quot;</span>);</span><br><span class="line"></span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">        singleLinkedList.add(hero1);</span><br><span class="line">        singleLinkedList.add(hero2);</span><br><span class="line">        singleLinkedList.add(hero3);</span><br><span class="line">        singleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义SingleLinkedList（创建链表）  管理英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先初始化一个头节点，头节点不能动(因为动了头节点之后遍历顺序会乱)</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);  <span class="comment">//private一个头节点，这样可以确保他不会移动</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//头节点不能动，需要一个辅助变量temp遍历</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//遍历，找到链表的最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没找到最后，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将最后节点的next指向一个新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示链表[遍历]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode temp = head.next;  <span class="comment">//这是不为空的情况</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp后移，不然会陷入死循环</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个类用于存放英雄的数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;  <span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化一下</span></span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//重写toString方法,用于输出信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickname=&#x27;&quot;</span> + nickname + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;  <span class="comment">//next不要写进去，不然每次输出会连带着下一个节点信息输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==思考一：为什么要重写 *<strong>toString*</strong> 方法？==</p><p> 一般这个方法的作用，是将对象中各个属性值按照字符串的形式输出出来(即以文本的方式表示此对象的字符串)，但是不重写***toString()***的话,输出的就是一个内存地址(哈希码值)。</p><p>==思考二：什么是重写？==</p><p> 指的是从父类继承之后，子类对于父类某方法的具体实现进行修改，你在<code>System.out.println()</code>一个对象时，是默认调用了<em><strong>toString()*<strong>这个方法的，将对象转为字符串输出，*</strong>toString()**<em>方法继承于所有类的隐性基类，如果某类无重写</em></strong>toString()*<strong>方法，这时调用</strong></em>toString()*<strong>将得到（类名+地址名名）这样的字符串。改成别的方法名是不能称为“重写”的。重写*</strong>toString()***方法可以输出自己想要的文字信息。</p><p>==小结==</p><p> 这个方法可以顺利输出英雄的顺序，但是如果在main函数中改变输入英雄的编号顺序，那么输出中英雄的编号顺序也会被打乱，那么就没法实现英雄排序这么一个功能了，所以就有了另外一个方法来插入英雄。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>思路：</p><p>大部分和方法一的差不多，主要关键点是找到插入的位置，判断编号是否存在，以及如何插入，与方法一一样，方法二任然需要辅助变量，来帮我们遍历链表。因为是单链表，不能找到前一个节点，所以在辅助变量移动到节点时，我们需要比较插入节点和辅助变量的下一个节点，然后根据情况是否符合将新节点插入到辅助变量后面。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//flag标志编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">//说明已经到链表的最后</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;</span><br><span class="line">                <span class="keyword">break</span>;      <span class="comment">//要让temp的下一个节点编号大于插入节点，才算找到位置</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;     <span class="comment">//编号存在，flag变为true，退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;  <span class="comment">//后移，遍历链表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;  <span class="comment">//编号存在，不能添加</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;插入英雄的编号 %d 已经存在，不能加入\n&quot;</span>, heroNode.no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            heroNode.next = temp.next;  <span class="comment">//插入到链表中，temp后面</span></span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面是一部分，将节点插入到单链表中，***flag***变量的存在，用来标识编号是否存在</p><p>==重点==：关键点是节点的插入</p><p> <code>heroNode.next = temp.next;</code></p><p> <code>temp.next = heroNode;</code></p><p> 我们要将节点插入到<strong>temp</strong>和<strong>temp.next</strong>之间，所以将<strong>heroNode.next</strong>指向<strong>temp.next</strong>(因为<strong>temp.next</strong>指向的下一个节点)，这样<strong>heroNode.next</strong>就可以指向下一个节点，而<strong>temp.next</strong>指向<strong>heroNode</strong>，就可以完成节点的连接了。</p><h2 id="节点的修改"><a href="#节点的修改" class="headerlink" title="节点的修改"></a>节点的修改</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;   <span class="comment">//判断链表是否为空</span></span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//表示是否找到该结点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到编号为 %d 的英雄\n&quot;</span>, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要是要修改的节点，再针对要改的属性就行修改</p><p>设置一个newHeroNode变量存放修改的数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HeroNode newHeroNode = <span class="keyword">new</span> HeroNode(修改的数据);</span><br><span class="line">SingleLinkedList.update(newHeroNode);</span><br></pre></td></tr></table></figure><p>在主函数中加入这两句即完成对节点数据的修改</p><h2 id="节点的删除"><a href="#节点的删除" class="headerlink" title="节点的删除"></a>节点的删除</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;   <span class="comment">//要找到删除节点的前一个节点</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;  <span class="comment">//后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.next = temp.next.next; <span class="comment">//将要删除的节点的前一个节点指向他的下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;要删除的 %d 节点不存在\n&quot;</span>, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> <code>temp.next = temp.next.next;</code></p><p> 删除的操作相对比较简单，将要删除的节点的前一个节点指向他的下一个节点，那么被删除的节点就没有指向了，成为无用的节点被垃圾回收机制回收</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java -数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建博客(hexo+github)</title>
      <link href="2021/04/24/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>2021/04/24/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>本篇文章主要会讲如何借用hexo框架来简单搭建一个属于自己的博客(基于Windows系统)，从前期准备到部署到github上一个时间并不长的流程。同时通过这种整理成册的方式来加深自己的印象(<del>不希望还有重新搭建的回忆</del>)，因为时间的问题，首次整理流程可能会有遗漏或者错误的地方，我会收集反馈和时不时检查来处理这些问题，下面就开始博客搭建之旅吧。</strong></p><h1 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h1><p>首先我们要安装两个重要的东西，他们是Git和node</p><p>node下载地址：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a>   (下载LTS版本，即长期支持版本，hexo需要node.js来支持)</p><p>Git下载地址：<a href="https://git-scm.com/">https://git-scm.com/</a></p><p>安装就一直点下一步直到安装结束就行了</p><p>安装好了这两个东西后可以在桌面鼠标右键选择git bash here打开git控制台</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> node <span class="literal">-v</span></span><br><span class="line"><span class="variable">$</span> npm <span class="literal">-v</span></span><br></pre></td></tr></table></figure><p>可以分别执行这两个操作来查看自己的node和npm的版本</p><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/4-24.1.76e7eqei4xk0.PNG" alt="查看版本"></p><p>初次使用git控制台，会让你注册，就是填邮箱和你的名称(自定义就行)</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git config -<span class="literal">-global</span> user.email <span class="string">&quot;你的邮箱&quot;</span></span><br><span class="line">git config -<span class="literal">-global</span> user.name <span class="string">&quot;名称&quot;</span></span><br></pre></td></tr></table></figure><p>他会出现这样上面这样的两行代码，你可以右键复制，一个个配置</p><h1 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h1><h2 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h2><p>在正式安装hexo框架前，还需要一个步骤，就是给我们的npm下载一个淘宝镜像源。因为我们的hexo是要npm这个包管理器来安装的，但是npm国内的镜像源速度很慢而且可能会漏东西。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> npm install <span class="literal">-g</span> cnpm -<span class="literal">-registry</span>=http://registry.npm.taobao.org    <span class="comment">#安装淘宝的cnpm 管理器</span></span><br></pre></td></tr></table></figure><p>之后都可以用cnpm来代替npm了</p><h2 id="安装Hexo框架"><a href="#安装Hexo框架" class="headerlink" title="安装Hexo框架"></a>安装Hexo框架</h2><p>现在来安装我们的hexo框架</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> cnpm install <span class="literal">-g</span> hexo<span class="literal">-cli</span>  <span class="comment">#安装hexo框架</span></span><br></pre></td></tr></table></figure><p>等待一会，下载完毕，同样你也可以通过<code>$ hexo -v </code>来查看hexo的版本</p><p>之后，选择你电脑中的一个位置新建一个文件夹，我的是在D盘下新建了一个blog文件夹，进入这个文件夹</p><p>在这个目录下git bash，我们要用hexo来生成我们的博客(==记住有关下面没有明确说的git命令都是在这个文件夹下执行的==)</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> hexo init    <span class="comment">#初始化</span></span><br></pre></td></tr></table></figure><p>命令完成之后，你的文件夹下面就会生成很多文件</p><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/4.24-2.68kw8cgr01c0.PNG" alt="可以不用和我的一样"></p><p> 到这里，hexo已经安装好了，我们可以来启动我们的博客</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> hexo s   <span class="comment"># s就是start，启动我们的博客</span></span><br></pre></td></tr></table></figure><p>我们会得到一个地址<a href="http://localhost:4000/">http://localhost:4000</a>,这个就是你没部署前可以访问的端口，但是断开就看不到了，不过后期部署后可以在页面渲染后用这个地址来提前预览</p><hr><p>我们的博客基本都是要使用markdown语法来写，你可以使用vscode或者typora来写你的md文件，不过相对来说改文件配置我倾向于vscode(<em>体积小，打开快，就是一些语法环境需要在里面装插件和改配置</em>)，写博客文章就用typora就好了。(<em>不过要学习一下markdown的语法，没关系很简单</em>)</p><hr><h1 id="在github部署"><a href="#在github部署" class="headerlink" title="在github部署"></a>在github部署</h1><p>当然，首先你要去github注册一个用户名，直接百度第一个就是，这一步自行注册</p><h2 id="生成ssh公钥"><a href="#生成ssh公钥" class="headerlink" title="生成ssh公钥"></a>生成ssh公钥</h2><p>注册好后我们先来配置我们的ssh公钥</p><p>在桌面git bash，执行以下的命令(可以直接按三次回车生成密钥)</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa</span><br></pre></td></tr></table></figure><p>生成的文件默认在~/.ssh目录中，看到有id_rsa，id_rsa.pub这些文件即可， Win10中就是 我的电脑/C盘/用户/你自己的用户名/.shh/ 就可以看到了,将id_rsa.pub这个文件在记事本中打开，复制里面的密钥。</p><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/4.24-3.3hcpwra4t2w0.png" alt="进入设置"></p><p>进入github，点击右上角头像进入setting</p><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/4.24-4.4m8k5ba1kzy0.png" alt="进入ssh配置"></p><p>点击ssh and gpg keys</p><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/4.24-5.2fl86gx6knvo.png" alt="key"></p><p>把你刚刚在那个文件里复制的密钥粘贴进这个key里面，直接确认</p><h2 id="构建仓库"><a href="#构建仓库" class="headerlink" title="构建仓库"></a>构建仓库</h2><p>点击github头像左边的+号，选择New repository创建一个新的仓库</p><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/4.24-6.24wtnkihsdog.png" alt="创建新仓库"></p><p>Repository name里面的格式必须是<code>你的github用户名.github.io</code>，Description中你想填什么都可以，仓库必须是Public的，之后点创建仓库就OK了，这个仓库以后就是你存放博客的仓库，他会管理你的代码。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>仓库建好后，我们需要下载一个部署插件</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> cnpm install hexo<span class="literal">-deployer</span><span class="literal">-git</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><h2 id="deploy配置"><a href="#deploy配置" class="headerlink" title="deploy配置"></a>deploy配置</h2><p>安装好后，在我们的博客根目录下，点击<code>_config.yml</code>来配置</p><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/4.24-7.676dsr01vu80.png" alt="配置文件"></p><p>可以用记事本或者vscode打开，当然我更推荐vscode，因为可以搜关键字:grin:,打开文件后</p><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/4.24-8.wxwzo1yhajk.png" alt="配置deploy"></p><p>翻到最下面，按照图中的格式来书写代码，注意冒号后面要有一个空格</p><p>==关于repo==</p><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/4.24-9.76ell65gr6s0.png" alt="repo地址"></p><p>可以选择HTTPS或者SSH，复制框中的内容，粘贴在repo里</p><p>==关于branch==(可看可不看，还是看吧)</p><p>最近github的默认分支换成了main，不过我觉得还是master更好一点，下面来换默认分支</p><p>点击仓库内的setting(注意是仓库内的)，点击Branchs，在default branch里点框后面的箭头按钮(switch)，把main换成master，然后update</p><p>这里就不放图了，太麻烦了</p><p><code>_config.yml</code>配置好后ctr+s保存一下</p><p>##运行Hexo</p><p>这时候执行下面三个命令</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> hexo clean</span><br><span class="line"><span class="variable">$</span> hexo g</span><br><span class="line"><span class="variable">$</span> hexo d   <span class="comment">#也可以把二三步换成 hexo d -g 一步到位，不过刚开始还是慢慢来</span></span><br></pre></td></tr></table></figure><p>如果出现要你配置git按照前面的步骤去走</p><p>刷新github仓库，会多很多东西</p><p>现在可以按照刚刚的<code>uername.github.io</code>来进行访问啦，没出来可以等一下，因为github更新的可能会有点慢</p><p>页面出来后就部署完成了！</p><h1 id="未完的话"><a href="#未完的话" class="headerlink" title="未完的话"></a>未完的话</h1><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>hexo有很多的主题可以去使用，hexo刚初始化时会默认使用landscape主题</p><p>可以去hexo主题官网里去选择下载，里面会有文档配置介绍<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><p>我用的是butterfly主题，他的文档介绍也是非常详细，功能什么的也很齐全</p><h2 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h2><p>除了部署在github上之外，其实还可以选择gitee(码云)，这两者各有优劣</p><p>github的速度是比不上gitee的，gitee每次更改完博客之后部署得很快，不用等多久</p><p>但是gitee每次都要在gitee pages里重新更新一下，而github不用，github pages是自动部署的</p><p>两者的步骤都差不太多</p><h2 id="图片加载问题"><a href="#图片加载问题" class="headerlink" title="图片加载问题"></a>图片加载问题</h2><p>因为要用markdown语法写文章，有时候遇到使用图片的问题</p><p>要么使用网络链接，要么本地链接，或者像我现在用的cdn外链，方法什么的都有</p><p>但主要是存放在哪是个问题，因为文章越写越多，这些图片需要有位置存放，一直放在本地也不太行</p><p>最好的办法就是图床来解决这个烦恼，起初图床困扰了我很久，问题到最近才得以解决</p><hr><p>目前主要就想到这么多，后面有想到的会再加，第一次写一写教程，关于未完的话里的内容后期看看有没有机会再整几篇</p><p>最后上个福利吧，酒保yyds</p><p><img src="https://cdn.jsdelivr.net/gh/FLASHyan/image@master/img-path/fuli.6wz6zqrf1cg0.jpg" alt="帅"></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -教程 -hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暴雨将至</title>
      <link href="2021/04/23/%E6%9A%B4%E9%9B%A8%E5%B0%86%E8%87%B3/"/>
      <url>2021/04/23/%E6%9A%B4%E9%9B%A8%E5%B0%86%E8%87%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&ensp;&ensp;&ensp;&ensp;天台上又刮起了风。</p><p>&ensp;&ensp;&ensp;&ensp;我站在一角，看着不知谁家的被单被风拍打地上下翻飞，开始有些担心，害怕它会被卷入这股风里，从这高处滑翔下去。风钻入我上身唯一一件白格子短袖中，头发也不听使唤地胡乱飘着。</p><p>&ensp;&ensp;&ensp;&ensp;闷燥的夏月，即使有风，我也能感受到一丝压迫感。天上的流云一块接一块，在仅存的微弱阳光中穿梭，终于连那最后一道光，也渐渐被吞噬掉。而我已经回到了室内走道，玻璃窗被急躁的风儿肆意敲打，我从裤兜里摸出一盒烟，快速点上一支，想在风的谢幕表演前把心中的气和烟一起吐出来，我眯着眼，望着这条狭长的走道，还没到开灯的点，这里看着就像个洗照片房里的暗室，远处只有紧急通道的灯光还在支撑，我很幸运，还能从这出去。</p><p>&ensp;&ensp;&ensp;&ensp;我掐灭了手里的烟，犹豫了一下，把它扔进了垃圾桶，顺手从上衣口袋中掏出了两条口香糖，我把它们塞进嘴里，糖纸被我揉成一团，一抛，没有一点声响，就落进了桶里。我径直穿过走道，直到那微弱的光从我头上掠过。</p><hr><p>&ensp;&ensp;&ensp;&ensp;朋友告诉我这是个多变的城市，可我反问他，</p><p>&ensp;&ensp;&ensp;&ensp; “你觉得我多变嘛？”</p><p>&ensp;&ensp;&ensp;&ensp;&ensp;他显然被我的这个问题给吓了一跳，一时回答不上来。我看着他这个样子，不免觉得有些好笑，</p><p>&ensp;&ensp;&ensp;&ensp;“那你觉得她多变嘛?”</p><p>&ensp;&ensp;&ensp;&ensp;问题问完，他缓缓看向我，叹了口气。</p><p>&ensp;&ensp;&ensp;&ensp;“你们还在闹矛盾吗？事情已经过去很久了，这气也该消了吧。” </p><p>&ensp;&ensp;&ensp;&ensp;其实，我很想告诉他，我跟她一点矛盾也没有，只是有些时候事情就这么摆在面前，你却找不到合适的方式去开口谈起它。</p><p>&ensp;&ensp;&ensp;&ensp;“把问题藏在心里不是个很好的方法哦，很容易把自己憋坏的。”</p><p>&ensp;&ensp;&ensp;&ensp;这句话我好像跟别人也说过，当时觉得这是一句很受用的话，虽然现在也这么觉得，但它似乎已经失去了一些值得被相信的理由，但即使到了这种地步你也不得不说出这句话。</p><hr><p>&ensp;&ensp;&ensp;&ensp;我还是没等到她。</p><p>&ensp;&ensp;&ensp;&ensp;我看了一眼手机，列车发车时间就要到了，她发信息说她临时有事不能来送我一程，我打了一段字，写了又删，最后干脆关机，将它扔进了包里，列车门开了，下车的人，上车的人，一个个好像都是面无表情的人偶，列车驶动，这个城市的风景被高速行驶的列车甩在身后，我靠在最里面的座位上，望着阴郁的天，知道不久就会有一场大暴雨登陆这个城市，我好像有点后悔，忘了跟她说记得带伞，但我还是没有敌过倦意，揣着包就这么在车上昏睡了过去。</p><p>&ensp;&ensp;&ensp;&ensp;我在夜色中下了车，头发乱糟糟的。打开手机，信息还停留在几个小时前，我似乎和她保持着一种默契，就像当时朋友遇见我们时说的那种默契，虽然我一直没搞懂她在说什么。</p><p>&ensp;&ensp;&ensp;&ensp;我盯着忙碌的拉面师傅，他就在我面前，为下一位客人准备食物。终于，他手上的事做完了，我的面还在汤里打转。</p><p>&ensp;&ensp;&ensp;&ensp;“小伙子，刚从火车站出来吧，抓点紧，等会就要下雨了。”</p><p>&ensp;&ensp;&ensp;&ensp;“没事师傅，我包里有伞。”</p><p>&ensp;&ensp;&ensp;&ensp;拉面师傅欣慰地朝我点了点头，嘴角那一抹弧线让我知道他今天应该是很开心的。其实我是骗他的，我的伞在那个城市的某个地方就已经不见了。我无意提了一下，她说要给我重新买一把，被我拒绝了，伞对我来说还算不上必备品，掉了就说明它跟我无缘，等哪个有缘人捡去，说不定就是一件善事了。</p><p>&ensp;&ensp;&ensp;&ensp;师傅转身又开始了新一轮的忙碌，我悄无声息地离开了拉面店，走了很远，总觉得刚刚应该跟他道个别，看他这么忙，还是要说声谢谢，可惜这句话连着面一起被我吞进了肚子里。</p><p>&ensp;&ensp;&ensp;&ensp;下次来再跟他说。</p><p>&ensp;&ensp;&ensp;&ensp;前面没有路灯。</p><hr><p>&ensp;&ensp;&ensp;&ensp;果然她没带伞，淋着雨回到了住所。</p><p>&ensp;&ensp;&ensp;&ensp;我觉得这次没什么好多说的，毕竟是我先关机的，很多事在事发之前没能想一个好的解决办法，等到发生了才开始追悔莫及，放在以前我绝对会对这个人的能力产生怀疑，但现在发现我其实没这个资格。</p><p>&ensp;&ensp;&ensp;&ensp;屏幕的光照在我的脸上，我聊了很多，道了晚安，手机依然握在手里，晚安只是说给愿意做梦的人听的，但事实上不是谁都想要做梦，我一度觉得没有说晚安的必要，但它总比拜拜要好一些，我没得选择，再加个表情，让他看上去不那么僵硬。我笑了，像在表演一出喜剧，摆弄脸上的表情，演给台下昏昏欲睡的观众，台词老套，让人提不起兴趣，人们撇嘴，开始对演员产生了质疑。临场发挥我看过很多，但要我做着实有些不合适。</p><p>&ensp;&ensp;&ensp;&ensp;想着还有闹钟，这次我没有选择关机。</p><hr><p>&ensp;&ensp;&ensp;&ensp;时间比我预期的早了点，本想把夏季梅雨的时节熬过去再和她谈明白，但她似乎还在惦记我丢失的那把雨伞，我苦笑，她也害羞地笑，我只好跟着附和。在我的印象里，那把伞的样子早就模糊了，只是没想到她还记得这么清楚。</p><p>&ensp;&ensp;&ensp;&ensp;“再买一把就好了。”我挠挠头。</p><p>&ensp;&ensp;&ensp;&ensp;“可是你没买。”</p><p>&ensp;&ensp;&ensp;&ensp;“……”</p><p>&ensp;&ensp;&ensp;&ensp;有时我很佩服她的洞察力，她其实对很多事是心知肚明的，只是嘴上不说，等到某个时候只需要一句话就能让你哑口无言。</p><p>&ensp;&ensp;&ensp;&ensp;我发现再这么聊下去恐怕天黑也开不了口，于是我选择岔开话题，她有些察觉，</p><p>&ensp;&ensp;&ensp;&ensp;“你是不是有什么心事?”</p><p>&ensp;&ensp;&ensp;&ensp;我有点恍惚，感觉这是我要问的问题，被她先问了出来，我的心扑通扑通地跳动，这和我看恐怖片时的感觉很像，只不过我从来不一个人看恐怖片。</p><p>&ensp;&ensp;&ensp;&ensp;总感觉那段时间很漫长，也很短暂。我甚至忘了我说了什么，忘了她的表情和她说的话，我只记得我一直在提醒自己要理智，得把话快点说完，赶着最后一趟班车回去。</p><p>&ensp;&ensp;&ensp;&ensp;出来前看了眼天气预报，才想起来自己还没有买伞。</p><p>&ensp;&ensp;&ensp;&ensp;我陪着她走回了家，一路上我们两个人一句话都没说。我又想起了那个人口中的默契，似乎一切都合情合理。到了家门口，她却有点挪不动脚步，我看到她眼角微红的印记，我只是站着发呆，想的许多的话憋到了嘴边，却只说了句，</p><p>&ensp;&ensp;&ensp;&ensp;“拜拜，晚安。”</p><p>&ensp;&ensp;&ensp;&ensp;我曾经对这种莫名的默契很是苦恼，但现在我反而觉得它出现的刚刚好，不想再多言一句，把这双赢的局面给破坏了。</p><hr><p>&ensp;&ensp;&ensp;&ensp;差点没赶上回来的车，上车随便找了个位子就坐下了。我感觉到气温的上升，雨水砸在地面上，拍打着车窗，我还是没能阻止暴雨的落下，雨幕把窗外的一切都打上了模糊的标记，闷燥的车厢里氤氲着湿热的水汽，广播里传来电台主持人的声音，他们大肆地笑着，我想跟着他们一起笑，虽然我没听清他们在笑什么。如果没下雨，我想去那家拉面店把我没说出来的话补上，或者，如果我手上有伞。</p><hr><p>&ensp;&ensp;&ensp;&ensp;我阻止不了这场暴雨，阻止不了她的离开，所以只能选择阻止自己，阻止自己进入这场暴雨，阻止自己进入她的生活。</p><hr><p>&ensp;&ensp;&ensp;&ensp;“你是不是忘了说什么?”</p><p>&ensp;&ensp;&ensp;&ensp;她留在原地不肯动，头微微低着，但还是在试着望向我。</p><p>&ensp;&ensp;&ensp;&ensp;我看着她的头发被风吹散，我察觉我的泪要止不住了。</p><p>&ensp;&ensp;&ensp;&ensp;“你知道我会说什么，”我顿了顿，我发现我好像一个忘了台词的演员，尴尬至极。</p><p>&ensp;&ensp;&ensp;&ensp;“拜拜。”我转身就要走。</p><p>&ensp;&ensp;&ensp;&ensp;“晚安。”</p><p>&ensp;&ensp;&ensp;&ensp;我听见身后她细弱的声音。</p><p>&ensp;&ensp;&ensp;&ensp;“晚安。”</p><p>&ensp;&ensp;&ensp;&ensp;我说完了最后一句话。</p><hr><p>&ensp;&ensp;&ensp;&ensp;END</p><p>&ensp;&ensp;&ensp;&ensp;(本文由歌曲 fun/Coldplay和rainy dumplings/饭碗的彼岸 所感而写)</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
